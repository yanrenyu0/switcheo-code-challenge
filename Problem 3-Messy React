/*
Computational inefficiencies and anti-patterns:
1)
'FormattedWalletBalance' should inherit from 'WalletBalance' as it just has an additional 'formatted' variable.

2)
Incorrect error handling in useEffect hook. console.err should be changed to console.error

3)
The 'blockchain' parameter is typed as 'any' which is not type safe and can lead to unexpected errors.
Since all cases in switch statement are strings, 'blockchain' parameter should be typed as 'string'

4)
'filter' method uses 'lhsPriority' which is not defined. Instead, 'balancePriority' should be used.

5)
'sort' method does not handle cases where priorities are equal. It can lead to inconsistent sorting or undefined behaviour.
The 'sort' method should return zero when 'leftPriority' is equal to 'rightPriority'.

6)
The code uses 'useMemo' and maps 'sortedBalances' twice.
The operations can be combined into a single step to improve performance.

7)
Missing 'blockchain' variable in WalletBalance interface.

Refactored version of the code:
FormattedWalletBalance not used, so I removed it
*/


interface WalletBalance {
    currency: string;
    amount: number;
    blockchain: string;
}

class Datasource {
    private url: string;

    constructor(url: string) {
        this.url = url;
    }

    async getPrices(): Promise<{ [key: string]: number }> {
        const response = await fetch(this.url);
        if (!response.ok) {
            throw new Error('Failed to fetch prices');
        }
        return response.json();
    }
}
interface Props extends BoxProps {

}
const WalletPage: React.FC<Props> = (props: Props) => {
    const { children, ...rest } = props;
    const balances = useWalletBalances();
    const [prices, setPrices] = useState({});

    useEffect(() => {
        const datasource = new Datasource("https://interview.switcheo.com/prices.json");
        datasource.getPrices().then(prices => {
            setPrices(prices);
        }).catch(error => {
            console.error(error);
        });
    }, []);

    const getPriority = (blockchain: string): number => {
        switch (blockchain) {
            case 'Osmosis':
                return 100
            case 'Ethereum':
                return 50
            case 'Arbitrum':
                return 30
            case 'Zilliqa':
                return 20
            case 'Neo':
                return 20
            default:
                return -99
        }
    }

    const rows = useMemo(() => {
        return balances.filter((balance: WalletBalance) => getPriority(balance.blockchain) > -99 && balance.amount > 0)
            .sort((lhs: WalletBalance, rhs: WalletBalance) => getPriority(rhs.blockchain) - getPriority(lhs.blockchain))
            .map((balance: WalletBalance, index: number) => {
                const formattedAmount = balance.amount.toFixed(2);
                const usdValue = prices[balance.currency] * balance.amount;
                return (
                    <WalletRow
                        className={classes.row}
                        key={index}
                        amount={balance.amount}
                        usdValue={usdValue}
                        formattedAmount={formattedAmount}
                    />
                );
            });
    }, [balances, prices]);


    return (
        <div {...rest} >
            {rows}
        </div>
    );
};

